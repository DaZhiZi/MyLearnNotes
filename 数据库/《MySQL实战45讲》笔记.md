# 《MySQL 实战 45 讲》学习笔记

## 1. 一条 SQL 查询语句是如何执行的

主要讲了 MySQL 的整体架构。

### MySQL 架构分层

![20190927200124.png](https://i.loli.net/2019/09/27/QRX6ViNHYZFIwSk.png)

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

### 连接器

- 默认的存储引擎是 InnoDB，建表的时候不指定就会默认成这个
- 连接器在完成 TCP 握手之后，连接器会对你进行身份认证，认证完成后，会从权限表里面找到所属的权限，然后进行加载，以后这个连接中的权限判断逻辑，都依赖此时查找的权限。
  - 这意味着，在这个连接没有结束之前，即使管理员账号对这个用户的权限进行了修改，也不影响已经存在的连接权限。修改完成后，只有新的连接才会使用新的权限设置
  - MySQL 中默认的断开时间是 8 小时，如果时间到了空闲连接一直没有断开，那么就会自动释放
- 在数据库中，**长连接**就是客户端有持续的请求，则一直使用同一个连接。**短连接**是指每次执行完很少的几次查询就进行释放。但是全部使用长连接后，内存会涨的很快，当到达一定程度后，就会被系统强行杀掉。
  - 定期断开长连接。使用一段时间后，或者程序判断中执行过一个占用内存比较大的查询后，先断开，之后又需要再重连
  - MySQL 版本>=5.7 可以执行`mysql_reset_connection`操作来进行初始化连接资源。**这个过程不需要重连和权限验证，但是连接会恢复到刚刚创建完成的状态**

### 查询缓存

MySQL 拿到一个查询请求后，会先查询缓存，如果之前执行过这一条语句，就可以在缓存中直接查到结果，直接返回给客户端。如果没有，就去查一下并且写到缓存中。

但是在实际情况下，不推荐开启这个功能。查询缓存往往弊大于利。

- 缓存失效频繁：一个表更新后，这个表的缓存就会失效
- 大量的查询场景下，查询缓存的命中率会特别低
- MySQL 8.0 版本开始，查询缓存功能就被丢弃了

### 分析器&优化器

分析器就是分析你输入的 sql 语句，进行词法分析。

优化器就是在一条 SQL 语句在执行之前，要先经过优化器的处理。在表里有很多索引的时候，决定使用哪个索引，或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序。

### 执行器

开始执行语句。开始执行时：

- 先判断你对这个表有没有执行权限，有就进行下一步，没有就报没权限的错误
- 有权限就打开表，然后根据表使用的引擎定义，去使用这个引擎提供的接口。

## 2. 一条 SQL 更新语句是如何执行的？

更新语句要用到两个重要的东西：

- redo log（重做日志）
- bin log（归档日志）

用于保证数据库 crash-safe 的能力

### redo log

redo log 是 InnoDB 特有的引擎

MySQL 中常说的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。就是有了查询语句先写在 redo log 中，然后**更新内存**，这个时候更新就算完成了，等到最后，MySQL 根据 redo log 中的内容再更新磁盘，这个更新往往是在系统比较空闲的时候。

InnoDB 的 redo log 是固定大小的，想想成一个环，从一个地方开始写，然后碰见了开头之后就把那部分的内容擦除掉，但是擦除掉之前要把这些记录更新在磁盘中。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

### binlog

MySQL 是 server 层和引擎层，server 层做一些功能层面的事情，引擎层负责存储相关的事宜。Server 层也有自己特有的日志，叫做 binlog（归档日志）.

因为 mysql 最初并没有 InnoDB 引擎，mysql 自带的引擎是 MyISAM, 但是他没有 crash-safe 的能力，所以，binlog 日志只能用于归档。InnoDB 是通过插件的形式进入到 MySQL 中的，既然自带的没有归档，所以就是用另一套日志系统，也就是 redo log 来实现 crash-safe 能力。

### 两种日志不同点

1. redo log 是 InnoDB 引擎特有的，而 binlog 是 Server 层特有的
2. redo log 是物理日志，记录的是「在某个数据页上做了什么修改」，binlog 是逻辑日志，记录的是这个语句的原始逻辑。
3. redo log 是循环写的，空间会用完；但是 bin log 是可以追加写入的。

下图是一个更新语句的流程图

![20190927211400.png](https://i.loli.net/2019/09/27/9wBEjQHMPgC2Zzk.png)

redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

### 两阶段提交

bin log 会记录所有的逻辑操作，采用「追加写」的方式。这样可以让数据库恢复到某一段时间内任意一个时刻的状态。

由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

- 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。
但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
- 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。