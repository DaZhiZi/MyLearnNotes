## 面向对象语法

### 面向对象三大特性

1. 封装
   - 定义类的准则
2. 继承
   - 设计类的技巧
   - 子类针对自己的特有需求，编写特定的代码
3. 多态
   - 多态可以增加代码的灵活度
   - 以继承和重写父类方法为前提
   - 是调用方法的技巧，不会影响到类的内部设计

### dir 内置函数

可以使用 dir 来查看一个对象里面都有什么方法。

下面是一些常用的方法/属性

| 序号 | 方法名     | 类型 | 作用                                   |
| ---- | ---------- | ---- | -------------------------------------- |
| 01   | `__new__`  | 方法 | 创建对象时，会被自动调用               |
| 02   | `__init__` | 方法 | 对象被初始化时，会被自动调用           |
| 03   | `__del__`  | 方法 | 对象被从内存中销毁前，会被自动调用     |
| 04   | `__dtr__`  | 方法 | 返回对象的描述信息，print 函数输出使用 |

### 定义简单的类

在Python中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:
    def 方法1(self, 参数列表):
        pass
    def 方法2(self, 参数列表):
        pass
```

- 方法的定义格式和函数几乎一样
- 区别于第一个参数必须是 self 

### 初始化方法

- 当使用 `类名()` 创建方法时，会自动使用 `__init__(self)`
- 为对象属性设置初始值
- 在 `__init__` 方法内部，可以指定一个对象的属性
- 当一个对象从内存中销毁前，会自动调用 `__del__` 方法，类似于析构函数？
- 生命周期就是从一个类创建开始，调用`__del__` 后结束

### 身份运算符

身份运算符用来比较两个对象的内存地址是否一致，是否是同一个对象的引用。

- 在 Python 中针对于 `None` 比较时，建议用 `is` 判断

| 运算符   | 描述                                      | 实例                           |
| -------- | ----------------------------------------- | ------------------------------ |
| `is`     | is 是判断两个标识符是不是引用同一个对象   | x is y ，类似 id(x)==id(y)     |
| `is not` | id not 是判断两个标识符是不是引用不同对象 | x is not y ，类似 id(a)!=id(b) |

`is` 与 `==` 的区别

- `is` 是判断两个变量的地址是不是一样
- `==` 是判断两个变量的值是不是一样

### 定义私有函数或者变量

- 只需要再方法名前或者属性前面加上两个下划线 `__` 即可
- 私有成员只允许类内访问
- 私有犯法也不允许在类外使用

但是，并不是真正意义上的私有，只是解释器中做了处理。

- 处理方式，在名称前面加上 `_类名` => `_类名__名称`

```python
# 私有属性
print(xiaofang._Women__age)

# 私有方法
xiaofang._Women__secret()
```

### 继承

继承的语法：

```python
class 类名(父类名)：
	pass
```

- 子类继承父类，可以直接享受父类中已经封装好的方法
- 子类中应该根据职责，封装子类特有的属性和方法
- 继承具有传递性，子类可以继承祖先类的方法和属性
- 当父类的方法不能满足子类的足球，可以对父类方法进行重写，方法是定义同一方法

**对父类方法进行扩展**：

- 如果只是对父类方法进行扩展时：
  1. 在子类中重写父类方法
  2. 在需要的位置使用 `super().父类方法()` 来调用父类方法的执行
  3. 代码的其他位置针对子类的需求，编写**子类特有的代码实现**
- 关于 `super`
  1. 在 Python 中是一个特殊的类
  2. `super()` 就是使用 `super` 类创建出来的对象
  3. 最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现

**调用父类方法的另一种方式**

在Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式： 

```python
父类名.方法名(self)
```

### 父类的 私有属性 和 私有方法

1. 子类对象不能再自己的方法内部，直接访问父类的私有属性或私有方法
2. 子类对象可以通过父类的公有方法间接访问到私有属性或私有方法

> - 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问
> - 私有属性、方法通常用于做一些内部的事情

### 多继承

概念

- 子类可以拥有多个父类，并且具有所有父类的属性和方法
- 例如：孩子会继承自己父亲和母亲的特性

语法

```python
class 子类名(父类名1,父类名2):
	pass
```

一些注意事项：

1. 如果在不同的父类中拥有同名的方法，子类对象在调用方法时，会调用第一个继承的类的方法，程序员在开发时要尽量注意避免这种

**Python 中的 MRO ---> 方法搜索顺序**

- Python 中针对 类 提供了一个内置属性 `__mro__` 可以查看 方法 搜索顺序
- MRO 是 `method resolution order` ，主要用于在 多继承时判断 方法、属性 的调用路径

```python
class A:
    def test(self):
        print('我是A')
class B():
    def test(self):
        print('我是B')
class C(B, A):
    pass
print(C.__mro__)

```

会输出：

```
(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
```

### 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的基类，提供一些内置的属性和方法，可以使用 `dir` 函数查看

- 新式类：以 `object` 为基类的类，推荐使用
- 经典类：不以 `object` 为基类的类，不推荐使用
- 在 Python 3.x 中，如果没有制定父类，会默认使用 `object` 作为基类
- 在 Python 2.x 中，如果没有制定父类，不会默认使用 `object` 作为基类

### 多态

举个例子

1. 在 `Dog` 类中封装方法 `game`
   - 普通狗只是简单的玩耍
2. 定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法
   - 哮天犬需要在天上玩耍
3. 定义 `Person` 类，并且封装一个 **和狗玩** 的方法
   - 在方法内部，直接让 **狗对象** 调用 `game` 方法

**案例小结**

1. `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗**
   - `game` 方法是在 `Dog` 父类中定义的
2. 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

例子：

```python
class Dog(object):
    def __init__(self, name):
        self.name = name

    def game(self):
        print('%s 蹦蹦跳跳的玩耍...' % self.name)


class XiaoTianQuan(Dog):
    def game(self):
        print('%s 飞到天上去玩耍...' % self.name)


class Person(object):
    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):
        print('%s 和 %s 快乐的玩耍...' % (self.name, dog.name))
        dog.game()


#wangcai = Dog("旺财")
wangcai = XiaoTianQuan("飞天旺财")
xiaoming = Person("小明")
xiaoming.game_with_dog(wangcai)

```

