## 第六讲 算法横向拆分，分离步骤

### 分析

- 存在两种不同层面的变化，应该有所区分
  - 在实现层面上：对于每个功能，存在多种实现方法
    - 相对与基类是可变的，每种变化对应与一个派生类
    - 这种变化表现在编译器，是一种静态的可变
  - 在组织层面上：「大」类的功能由一系列子功能构成
    - 子功能之间是相互独立的，应当将这些子功能拆分到不同的「小类」
    - 组合是自由的、动态的、可变的，通过实现子功能的「小」类对象的组合来完成
    - 这种变化表现在运行期，是一种更加动态的可变
- 隔离不同层面的变
  - 静态的可变用继承
  - 动态的可变用组合

### 单一责任

- 单一责任原则
  - 类的功能应该是内聚的，一个类只承担一项功能
  - 表现为：修改/派生一个雷只应该有一个理由，只能够由单个变化因素引起
- 将多个不同的功能交由同一个类实现，违反了单一责任原则
  - 当一个功能需要变化时，不得不修改或者派生新的实现类

### 把这两个层次的「变」分离开

- 用组合代替
  - 用功能（算法）接口之间的组合来实现功能（算法）之间的组合
- 