# 基础语法和易混淆的概念

记录C++的重要的基础语法以及易混淆的概念。

## 指针

指针易混淆的概念：

### 常量指针和指针常量和常量指针常量

**常量指针：**指向常量的指针。

示例一：

```cpp
int n = 10;
const int *p = &n;
```

此时不能通过指针修改数据对象的值，但可以改变指针的指向。比如此时指针p不能改变n的值，但是可以指向另一个变量，把上面的代码做修改:

```cpp
int n = 10, m = 30;
const int *p = &n;//常量指针p初始化指向n
*p = 20;// 这一步错误，这是一个常量指针，不能更改目标数据对象的值
p = &m;//这一步正确，可以修改指向
```



示例二:

```cpp
void PrintObj(const int *p);
```

比如我们要定义一个函数，功能是打印某个对象的值，我们此时只希望函数有打印功能，不希望传进来的指针可以被修改，我们就把它变成**常量指针**，这样就只能打印，不能修改.

**指针常量：**指针指向的位置不可变化。

要注意一下，**指针常量和其他常量一样，必须在定义时初始化。**

此时不可以把指针指向其他地方，但是可以改变指针所指的目标数据对象的值。

示例一：

```cpp
int n = 10, m = 30;
int *const p = &n;//定义一个指针常量指向n
*p = 40;//合法，可以改变指针所指的目标数据对象的值
p = &m;//不合法，不能修改指针指向。
```

**常量指针常量：**指向常量的指针常量（指针的双重只读属性）

他的性质是：**指针值不可改变，指向的目标数据对象也不可改变。**

```cpp
int n = 10, m = 30;
const int *const p = &n;
*p = 40;//错误
p = &m;//错误
```

使用场合，作为函数的参数.

### 指针作为函数返回值

指针类型可以作为函数返回值，调用函数候将返回值赋值给某个指针。

但是，**不能返回函数内部定义的局部变量地址**，只能返回某个全局量的地址。

```cpp
int global = 0;
int *ReturnPointer()
{
    return &global;
}
```

这样写便是合法的。

## 类与对象

类与对象的相关重要知识。

### 友元

有时需要允许某些函数访问对象的私有成员，可以通过声明该函数为类的**友元**来实现。

> 在C++中，`struct`中的成员默认是`public`的，而`class`中的成员默认是`private`的。

所以再允许某些函数访问私有对象成员时，要用友元来实现。如：

```cpp
class Test
{
    int id;
  public:
    friend void print(Test T);
};
void print(Test T)
{
    cout << T.id << endl;
}
```

## 拷贝构造函数

- 函数调用时以类的对象为形参或返回类对象时，编译器会自动生成**拷贝构造函数**，在已有对象的基础上生成新对象。

- 拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用。
- 语义上：用参数对象的内容初始化当前对象。

```cpp
class Test
{
  public:
    Test()
    {
        cout << "Test()~" << endl;
    }
    Test(const Test &src)
    {
        cout << "Test(const Test& src)" << endl;
    }
    ~Test()
    {
        cout << " ~Test()" << endl;
    }
};
void func1(Test obj)
{
    cout << "func1()~" << endl;
}
Test func2()
{
    cout << "func2()" << endl;
    return Test();
}
int main()
{
    cout << "main()" << endl;
    Test t;
    func1(t);
    t = func2();
    return 0;
}
```

输出如下:

```cpp
main()  //main被调用
Test()~ //构造函数被调用
Test(const Test& src) //编译器拷贝了一个对象，自动调用了拷贝构造函数
func1()~ // 函数1被调用
 ~Test() //新的对象被销毁了，所以调用了析构函数
func2()  //函数2被调用
Test()~  // 返回Test()的时候，产生一个新对象
 ~Test() // 释放fun2产生的临时对象
 ~Test() // 释放局部变量t
```

## 运算符重载

### 赋值运算符重载

- 赋值运算符实在类中定义的特殊成员函数
- 典型的实现方式

```cpp
class Test
{
    int id;
  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    Test &operator=(const Test &right)
    {
        if (this == &right)//判断是否是同一个对象
            cout << "same obj!\n";
        else
        {
            cout << "obj_" << id << " =obj_" << right.id << endl;
            this->id = right.id;
        }
        return *this;
    }
};
```

### 流运算符重载

典型声明方式：

```cpp
istream &operator>>(istream &in, Test &det);
ostream &operator<<(ostream &out, const Test &src);
```

- 函数名为：`istream>>`和`operator<<`
- 返回值为：`istream&`和`ostream&`，均为引用
- 参数分别为：流对象的引用、目标对象的引用。对于输出流，目标对象还是常量。  

**如果想让流运算符可以使用一个类的私有对象，那么就将流运算符函数声明为类的友元。**

示例

```cpp
class Test
{
    int id;

  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    friend istream &operator>>(istream &in, Test &dst);
    friend ostream &operator<<(ostream &out, const Test &src);
};
//以上类中声明了Test类的两个友元函数---全局流运算符重载函数
//使这两个函数在实现时可以访问对象的私有成员(如 int id)
```

完整示例

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
    int id;

  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    friend istream &operator>>(istream &in, Test &dst);
    friend ostream &operator<<(ostream &out, const Test &src);
};
istream &operator>>(istream &in, Test &dst)//对于定义的实现
{
    in >> dst.id;
    return in;
}
ostream &operator<<(ostream &out, const Test &src)
{
    out << src.id << endl;
    return out;
}
int main()
{
    Test obj(1);
    cout << obj;
    cin >> obj;
    cout << obj;
    return 0;
}
```

### 函数运算符`()`重载

- 函数运算符`()`也能重载，它使对象看上去像是一个函数名

```cpp
Return operator()(Parameters) {}//定义运算符重载
ClassName Obj;//创建函数
Obj(real_parameters);//相当于 Obj.operator() (real_parameters)
```

完整示例

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
  public:
    int operator()(int a, int b)
    {
        cout << "operator() called. " << a << " " << b << endl;
        return a + b;
    }
};
int main()
{
    Test sum;
    int s = sum(3, 4);//sum对象看上去像是一个函数，所以也称作"函数对象"
    cout << "a + b = " << s << endl;
    return 0;
}
```

通过一个重载圆括号，使得`Test`这个类生成的任何对象，都有了一个`()`函数，可以进行加法运算.



