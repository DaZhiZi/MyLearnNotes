# 基础语法和易混淆的概念

记录C++的重要的基础语法以及易混淆的概念。

## 指针

指针易混淆的概念：

### 常量指针和指针常量和常量指针常量

**常量指针：**指向常量的指针。

示例一：

```cpp
int n = 10;
const int *p = &n;
```

此时不能通过指针修改数据对象的值，但可以改变指针的指向。比如此时指针p不能改变n的值，但是可以指向另一个变量，把上面的代码做修改:

```cpp
int n = 10, m = 30;
const int *p = &n;//常量指针p初始化指向n
*p = 20;// 这一步错误，这是一个常量指针，不能更改目标数据对象的值
p = &m;//这一步正确，可以修改指向
```



示例二:

```cpp
void PrintObj(const int *p);
```

比如我们要定义一个函数，功能是打印某个对象的值，我们此时只希望函数有打印功能，不希望传进来的指针可以被修改，我们就把它变成**常量指针**，这样就只能打印，不能修改.

**指针常量：**指针指向的位置不可变化。

要注意一下，**指针常量和其他常量一样，必须在定义时初始化。**

此时不可以把指针指向其他地方，但是可以改变指针所指的目标数据对象的值。

示例一：

```cpp
int n = 10, m = 30;
int *const p = &n;//定义一个指针常量指向n
*p = 40;//合法，可以改变指针所指的目标数据对象的值
p = &m;//不合法，不能修改指针指向。
```

**常量指针常量：**指向常量的指针常量（指针的双重只读属性）

他的性质是：**指针值不可改变，指向的目标数据对象也不可改变。**

```cpp
int n = 10, m = 30;
const int *const p = &n;
*p = 40;//错误
p = &m;//错误
```

使用场合，作为函数的参数.

### 指针作为函数返回值

指针类型可以作为函数返回值，调用函数候将返回值赋值给某个指针。

但是，**不能返回函数内部定义的局部变量地址**，只能返回某个全局量的地址。

```cpp
int global = 0;
int *ReturnPointer()
{
    return &global;
}
```

这样写便是合法的。

## 类与对象

类与对象的相关重要知识。

### 友元

有时需要允许某些函数访问对象的私有成员，可以通过声明该函数为类的**友元**来实现。

> 在C++中，`struct`中的成员默认是`public`的，而`class`中的成员默认是`private`的。

所以再允许某些函数访问私有对象成员时，要用友元来实现。如：

```cpp
class Test
{
    int id;
  public:
    friend void print(Test T);
};
void print(Test T)
{
    cout << T.id << endl;
}
```

## 拷贝构造函数

- 函数调用时以类的对象为形参或返回类对象时，编译器会自动生成**拷贝构造函数**，在已有对象的基础上生成新对象。

- 拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用。
- 语义上：用参数对象的内容初始化当前对象。

```cpp
class Test
{
  public:
    Test()
    {
        cout << "Test()~" << endl;
    }
    Test(const Test &src)
    {
        cout << "Test(const Test& src)" << endl;
    }
    ~Test()
    {
        cout << " ~Test()" << endl;
    }
};
void func1(Test obj)
{
    cout << "func1()~" << endl;
}
Test func2()
{
    cout << "func2()" << endl;
    return Test();
}
int main()
{
    cout << "main()" << endl;
    Test t;
    func1(t);
    t = func2();
    return 0;
}
```

输出如下:

```cpp
main()  //main被调用
Test()~ //构造函数被调用
Test(const Test& src) //编译器拷贝了一个对象，自动调用了拷贝构造函数
func1()~ // 函数1被调用
 ~Test() //新的对象被销毁了，所以调用了析构函数
func2()  //函数2被调用
Test()~  // 返回Test()的时候，产生一个新对象
 ~Test() // 释放fun2产生的临时对象
 ~Test() // 释放局部变量t
```



