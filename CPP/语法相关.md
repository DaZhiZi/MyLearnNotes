# 基础语法和易混淆的概念

记录C++的重要的基础语法以及易混淆的概念。

## 指针

指针易混淆的概念：

### 常量指针和指针常量和常量指针常量

**常量指针：**指向常量的指针。

示例一：

```cpp
int n = 10;
const int *p = &n;
```

此时不能通过指针修改数据对象的值，但可以改变指针的指向。比如此时指针p不能改变n的值，但是可以指向另一个变量，把上面的代码做修改:

```cpp
int n = 10, m = 30;
const int *p = &n;//常量指针p初始化指向n
*p = 20;// 这一步错误，这是一个常量指针，不能更改目标数据对象的值
p = &m;//这一步正确，可以修改指向
```



示例二:

```cpp
void PrintObj(const int *p);
```

比如我们要定义一个函数，功能是打印某个对象的值，我们此时只希望函数有打印功能，不希望传进来的指针可以被修改，我们就把它变成**常量指针**，这样就只能打印，不能修改.

**指针常量：**指针指向的位置不可变化。

要注意一下，**指针常量和其他常量一样，必须在定义时初始化。**

此时不可以把指针指向其他地方，但是可以改变指针所指的目标数据对象的值。

示例一：

```cpp
int n = 10, m = 30;
int *const p = &n;//定义一个指针常量指向n
*p = 40;//合法，可以改变指针所指的目标数据对象的值
p = &m;//不合法，不能修改指针指向。
```

**常量指针常量：**指向常量的指针常量（指针的双重只读属性）

他的性质是：**指针值不可改变，指向的目标数据对象也不可改变。**

```cpp
int n = 10, m = 30;
const int *const p = &n;
*p = 40;//错误
p = &m;//错误
```

使用场合，作为函数的参数.

### 指针作为函数返回值

指针类型可以作为函数返回值，调用函数候将返回值赋值给某个指针。

但是，**不能返回函数内部定义的局部变量地址**，只能返回某个全局量的地址。

```cpp
int global = 0;
int *ReturnPointer()
{
    return &global;
}
```

这样写便是合法的。

## 类与对象

类与对象的相关重要知识。

### 友元

有时需要允许某些函数访问对象的私有成员，可以通过声明该函数为类的**友元**来实现。

> 在C++中，`struct`中的成员默认是`public`的，而`class`中的成员默认是`private`的。

所以再允许某些函数访问私有对象成员时，要用友元来实现。如：

```cpp
class Test
{
    int id;
  public:
    friend void print(Test T);
};
void print(Test T)
{
    cout << T.id << endl;
}
```

### 拷贝构造函数

- 函数调用时以类的对象为形参或返回类对象时，编译器会自动生成**拷贝构造函数**，在已有对象的基础上生成新对象。

- 拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用。
- 语义上：用参数对象的内容初始化当前对象。

```cpp
class Test
{
  public:
    Test()
    {
        cout << "Test()~" << endl;
    }
    Test(const Test &src)
    {
        cout << "Test(const Test& src)" << endl;
    }
    ~Test()
    {
        cout << " ~Test()" << endl;
    }
};
void func1(Test obj)
{
    cout << "func1()~" << endl;
}
Test func2()
{
    cout << "func2()" << endl;
    return Test();
}
int main()
{
    cout << "main()" << endl;
    Test t;
    func1(t);
    t = func2();
    return 0;
}
```

输出如下:

```cpp
main()  //main被调用
Test()~ //构造函数被调用
Test(const Test& src) //编译器拷贝了一个对象，自动调用了拷贝构造函数
func1()~ // 函数1被调用
 ~Test() //新的对象被销毁了，所以调用了析构函数
func2()  //函数2被调用
Test()~  // 返回Test()的时候，产生一个新对象
 ~Test() // 释放fun2产生的临时对象
 ~Test() // 释放局部变量t
```

### 类中的静态数据成员

在类型前面加上`static`修饰的数据成员，是隶属于类的，称为类的静态数据成员，也称`类变量`

- 静态数据成员被该类的所有对象共享（即所有对象中的这数据域实际上处于同一内存位置）

- 静态数据成员要在实现文件中赋初值，格式为：

  ```cpp
  Type ClassName::static_var = Value;
  ```

- 返回值类型前面加上`static`修饰的成员函数，称为静态成员函数，他们**不能调用非静态成员函数**，因为没有`this`指针

- 类的静态成员（数据、函数）既可以通过对象来访问，也可以通过类名来访问。

举个栗子：

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
    static int count;

  public:
    Test()
    {
        printf("开始构造!!\n");
        count++;
    }
    ~Test()
    {
        printf("开始析构!!\n");
        count--;
    }
    static int how_many() { return count; }
};
int Test::count = 0;
void print(Test t)
{
    cout << "in print(),Test#: " << t.how_many() << endl;
}
int main()
{
    Test t1;
    cout << "Test#: " << Test::how_many() << endl; //构造了t1对象，count=1
    Test t2 = t1;                                     //此时并没有调用构造函数
    cout << "Test#: " << Test::how_many() << endl;  //输出 1
    print(t2);  //函数完成时会析构，所以count-- 变成了 1
    cout << "Test#: " << t1.how_many() << ", " << t2.how_many() << endl; //变成0
    return 0;
}
```

### 类中的常量成员

- 使用 const 来修饰的数据成员，称为类的常量数据成员，在对象的整个生命周期里不可更改
  - 常量数据成员只能**在构造函数的初始化列表被设置**，不允许在函数体中通过赋值来设置。
- 若使用 const 来修饰成员函数，则该成员函数在实现的时不能修改类的数据成员，即函数体中不能有改变对象状态（内容）的语句
  - 若对象被定义为常量，则它只能调用以 const 修饰的成员函数，其他普通成员函数不允许调用。

举个例子：

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
    const int ID;

  public:
    Test(int id) : ID(id) {}
    int MyID() const { return ID; } //const来修饰
    // 不可被改变
    // int Next() const
    // {
    //     ID++;
    //     return ID;
    // }
    int Who() { return ID; }
};

int main()
{
    Test obj1(20181231);
    cout << "ID_1 = " << obj1.MyID() << endl;
    cout << "ID_2 = " << obj1.Who() << endl;
    const Test obj2(20191231);
    cout << "id_1 : " << obj2.MyID() << endl;
    // 会报错，因为obj2是常量对象，语义上来讲是不可修改的
    //cout << "id_2 : " << obj2.Who() << endl;
    return 0;
}
```

### 包含其他类的对象

- 可以在类中使用其他类来定义数据成员，通常称为`子对象`。这种包含与被包含的对象间的关系称为`组合`，组合关系可以嵌套
- 子对象构造时若需要参数，则应当在当前类的构造函数的初始化列表中进行。若使用默认构造函数来构造子对象，则不用做任何处理。
- 对象的构造与析构次序
  1. 先完成子对象构造，再完成当前对象构造
  2. 对象析构的次序与对象构造的次序是相反的

举个栗子：

```cpp
#include <bits/stdc++.h>
using namespace std;
class C1
{
    int ID;

  public:
    C1(int id) : ID(id) { cout << "C1(int)" << endl; }
    ~C1() { cout << "~C1()" << endl; }
};
class C2
{
  public:
    C2() { cout << "C2()" << endl; }
    ~C2() { cout << "~C2()" << endl; }
};
class C3
{
    int num;
    C1 sub_obj1;
    C2 sub_obj2;

  public:
    C3() : num(0), sub_obj1(123) { cout << "C3()" << endl; }
    C3(int n) : num(n), sub_obj1(123) { cout << "C3(int)" << endl; }
    C3(int n, int k) : num(n), sub_obj1(k)
    {
        cout << "C3(int,int)" << endl;
    }
    ~C3() { cout << "~C3()" << endl; }
};
int main()
{
    C3 a, b(1), c(2), d(3, 4);

    return 0;
}
```

观察上面的输出，就会知道构造和析构的顺序。

### 移动构造函数

见：[移动构造函数](CPP11新特性/移动构造函数.md)

### `=default`(显式缺省）

再默认函数定义或声明加上`=default`，可显式的指示编译器生成该函数的默认版本

```cpp
class T
{
    int data;
  public:
    T() = default;//默认使用编译器提供的构造函数
    T(int i) : data(i) {}
};
```



## 运算符重载

### 赋值运算符重载

- 赋值运算符实在类中定义的特殊成员函数
- 典型的实现方式

```cpp
class Test
{
    int id;
  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    Test &operator=(const Test &right)
    {
        if (this == &right)//判断是否是同一个对象
            cout << "same obj!\n";
        else
        {
            cout << "obj_" << id << " =obj_" << right.id << endl;
            this->id = right.id;
        }
        return *this;
    }
};
```

### 流运算符重载

典型声明方式：

```cpp
istream &operator>>(istream &in, Test &det);
ostream &operator<<(ostream &out, const Test &src);
```

- 函数名为：`istream>>`和`operator<<`
- 返回值为：`istream&`和`ostream&`，均为引用
- 参数分别为：流对象的引用、目标对象的引用。对于输出流，目标对象还是常量。  

**如果想让流运算符可以使用一个类的私有对象，那么就将流运算符函数声明为类的友元。**

示例

```cpp
class Test
{
    int id;

  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    friend istream &operator>>(istream &in, Test &dst);
    friend ostream &operator<<(ostream &out, const Test &src);
};
//以上类中声明了Test类的两个友元函数---全局流运算符重载函数
//使这两个函数在实现时可以访问对象的私有成员(如 int id)
```

完整示例

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
    int id;

  public:
    Test(int i) : id(i) { cout << "obj_" << id << " created\n"; }
    friend istream &operator>>(istream &in, Test &dst);
    friend ostream &operator<<(ostream &out, const Test &src);
};
istream &operator>>(istream &in, Test &dst)//对于定义的实现
{
    in >> dst.id;
    return in;
}
ostream &operator<<(ostream &out, const Test &src)
{
    out << src.id << endl;
    return out;
}
int main()
{
    Test obj(1);
    cout << obj;
    cin >> obj;
    cout << obj;
    return 0;
}
```

### 函数运算符`()`重载

- 函数运算符`()`也能重载，它使对象看上去像是一个函数名

```cpp
Return operator()(Parameters) {}//定义运算符重载
ClassName Obj;//创建函数
Obj(real_parameters);//相当于 Obj.operator() (real_parameters)
```

完整示例

```cpp
#include <bits/stdc++.h>
using namespace std;
class Test
{
  public:
    int operator()(int a, int b)
    {
        cout << "operator() called. " << a << " " << b << endl;
        return a + b;
    }
};
int main()
{
    Test sum;
    int s = sum(3, 4);//sum对象看上去像是一个函数，所以也称作"函数对象"
    cout << "a + b = " << s << endl;
    return 0;
}
```

通过一个重载圆括号，使得`Test`这个类生成的任何对象，都有了一个`()`函数，可以进行加法运算.

再举个栗子:

可以用一个变化的量来设定一个函数的内容.

```cpp
#include <bits/stdc++.h>
using namespace std;
class Less
{
    int thres_;
  public:
    Less(int th) : thres_(th) {}
    bool operator()(int);
};
bool Less::operator()(int value) //重载括号运算符
{
    return value < thres_;
}
void Filter(int *arry, int num, Less fn)
{
    for (int i = 0; i < num; i++)
        if (fn(arry[i])) //输出小于fn这个对象的thres_的值
            cout << arry[i] << " ";
    cout << endl;
}
int main()
{
    int arry[5] = {1, -4, 10, 0, -1};
    int thres;
    cout << "thres:";
    cin >> thres;
    Less less_than(thres);
    Filter(arry, 5, less_than);
    return 0;
}
```

### 数组下标运算符`[]`重载

函数声明形式:

```cpp
返回类型 operator[](参数);
```

如果返回类型是引用，则数组运算符调用可以出现在等号左边，接受赋值，即：

```cpp
obj[index] = value;
```

如果返回类型不是引用，则只能出现在等号右边:

```cpp
var = obj[index];
```

举个栗子:

```cpp
#include <bits/stdc++.h>
using namespace std;
char week_name[7][4] = {"mon", "tu", "wed", "thu", "fri", "sat", "sun"};
class WeekTemp
{
    int temp[7];
  public:
    int &operator[](const char *name) //字符串做下标
    {
        for (int i = 0; i < 7; i++)
            if (strcmp(week_name[i], name) == 0)
                return temp[i];
    }
};
int main()
{
    WeekTemp beijing;
    beijing["mon"] = -3;
    beijing["tu"] = -1;
    cout << "Monday Temperature: " << beijing["mon"] << endl;
    return 0;
}
```

通过重载运算符可以使得`[]`可以里面接受字符串，因为利用了引用，所以可以`[]`放在左边.

### 重载前缀和后缀`++/--`运算符

前缀运算符重载声明：

```cpp
ReturnType operator++();
ReturnType operator--();
```

后缀运算符重载声明：

```cpp
ReturnType operator++(int dummy);
ReturnType operator--(int dummy);
```

通过再函数参数中的哑元参数 dummy 来区分前缀与后缀的同名重载。哑元的意思是：在函数体语句中没有使用该参数。

## 继承

- 在已有类的基础上，可以通过`继承`来定义新的类，实现对已有代码的复用
- 常见的继承方式:`public`和`private`
  - `class Derived:[private] Base{...};`缺省继承是`private`继承
  - `class Derived:piblic Base {...}`;
- 被继承的已有类，被称为`基类`，也称`父类`
- 通过继承得到的新的类，被为`派生类(derived class)`也称为`子类`,`扩展类`

### 初始化:

1. 基类的数据成员中，通过继承称为派生类对象的一部分，需要在构造派生类的过程中调用基类的构造函数来正确初始化
   - 若没有显式调，编译器会自动生成一个对基类的默认构造函数的调用
   - 若想要显式调用，则只能再派生类的构造函数的初始化成员列表中进行，既可以调用基类中不带参数的默认构造函数，也可以调用合适的带参数的其他构造函数
2. 先执行基类的构造函数来初始化继承来的数据，再执行派生类的构造函数
3. 对象析构时，先执行派生类的析构函数，再执行由编译器自动调用的析构函数

### 继承类的构造函数(1):

- 在派生类中使用`using Base::Base;`来继承基类的构造函数，相当于给派生类定义了相应参数的构造函数

```cpp
#include <iostream>
using namespace std;
class Base
{
    int data;

  public:
    Base(int i) : data(i) { cout << "Base::Base(" << i << ")\n"; }
};
class Derive : public Base
{
    int data{2016};

  public:
    using Base::Base;
    void print()
    {
        cout << "data = " << data << endl;
    }
};
int main()
{
    Derive obj(356);
    obj.print();
    return 0;

    return 0;
}
```

输出结果:

```
Base::Base(356)
data = 2016
```

相当于继承了构造函数

### 继承类的构造函数(2):

- 虽然基类的构造函数参数默认值不会被派生类继承，但由默认参数导致的多个构造函数版本都会被派生类继承
- 如果基类的某个构造函数被声明为私有成员函数，则不能在派生类中声明继承该构造函数
- 如果派生类中使用了继承基类构造函数，编译器就不会再为派生类生成默认构造函数

### 派生类(对象中的基类成员)

1. 派生类对象包含从基类继承来的数据成员，他们构成了`基类子对象`'
2. 基类中的私有成员，不允许在派生类成员函数中被访问，也不允许派生类的对象访问他们
   - 真正体现`基类私有`，对派生类也不开放其权限
3. 基类中的公有成员:
   - 若是使用`public`的继承方式，则成为派生类的公有成员，既可以在派生类成员函数中访问，也可以被派生类的对象访问
   - 若是使用`private`的继承方式，则只能供派生类成员函数访问，不能被派生类的对象访问。

例子:

```cpp
#include <iostream>
using namespace std;
class B
{
  public:
    void f()
    {
        cout << "in B::f()..." << endl;
    }
};
class D1 : public B
{
};
class D2 : private B
{
  public:
    void g()
    {
        cout << "in D2::g(),calling f()..." << endl;
        f(); //私有继承时，基类接口在子类成员函数中可以使用
    }
};
int main()
{
    cout << "in main()..." << endl;
    D1 obj1;
    cout << "calling obj1.f()..." << endl;
    obj1.f(); //基类接口是子类的一部分
    D2 obj2;
    cout << "calling obj2.g()..." << endl;
    obj2.g();
    // obj2.f();   基类接口不允许调用子类对象
    return 0;
}

```

### 派生类重写基类函数

- 基类已经定义的成员函数，在派生类中可以重新定义它，被称为`函数重写`
- 重写发生时，基类中该成员函数的其他重载函数将被屏蔽掉，不能提供给派生类对象使用
- 可以在派生类中通过`using 类名::成员函数名;`在派生类中恢复指定的成员函数
- 同名函数都被屏蔽

