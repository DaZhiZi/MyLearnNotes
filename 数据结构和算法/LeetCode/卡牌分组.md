题目链接：[卡牌分组](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)

给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

 

示例：

```
输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。
```


提示：

```
1 <= words.length <= 2000
1 <= words[i].length <= 7
每个单词都是小写字母 。
```

## 思路

两种思路，第一种暴力，枚举符合长度的k.

```cpp
class Solution
{
public:
    bool hasGroupsSizeX(vector<int> &deck)
    {
        unordered_map<int, int> mp;
        for (auto num : deck)
            mp[num]++;
        int len = deck.size();
        for (int x = 2; x <= len; x++)
        {
            if (len % x != 0)
                continue;
            int ans = 0;
            for (auto it : mp)
            {
                if (it.second % x != 0)
                {
                    break;
                }
                else
                {
                    ans += it.second;
                }
            }
            if (ans == len)
                return true;
        }
        return false;
    }
};

```

第二种，不难发现，要分成多组，x必须被长度整除，也需要被数量整除，只需要算出这些的gcd，求出是否大于等于2就是答案。

```cpp
class Solution
{
public:
    bool hasGroupsSizeX(vector<int> &deck)
    {
        unordered_map<int, int> mp;
        for (auto num : deck)
            mp[num]++;
        int gcd = deck.size();
        for (auto it : mp)
        {
            gcd = __gcd(gcd, it.second);
        }
        return gcd >= 2;
    }
};
```



