## 腾讯面经总结

下面是腾讯的面经总结

## 数据结构和算法

1. 一个数怎么判断是不是 2 的幂次？具体实现？

   答：`n&(n-1)`

2. 两个链表某节点开始重合，求第一次重合的位置

   答：先求长度，然后跳

3. 讲一下快排,有几大排序；堆排序的复杂度；底层实现；归并排序的复杂度；快速排序；  它们的稳定性；需不需要打乱？

4. 两个栈实现一个队列

   答：直接实现。

5. 红黑树的特性

6. 常见的排序算法和复杂度

7. 数组找第 k 大的数

   答：①排序②优先队列③partition

8. 非递归二分查找

9. 链表相加



## C++

1. 简单说说多态

   答：静态多态：函数重载

   ​	运行时多态：虚函数

   ​	指向基类的指针在操作它的多态类对象时，会根据不同的类对象调用相应对象的函数，这个函数就是虚函数.

   ​	虚函数表保存了虚函数的地址，用父类指针操作一个子类的时候，指向实际调用的函数。

2. c 语言的 strcpy 函数有什么弊端？怎么用一句代码判断是否发生内存重叠？有看过它的源码吗？出了内存重叠还有什么弊端？

   答：

   **strcpy**:拷贝

   ```cpp
   char* strcpy(char* des, const char* src)
   {
   	assert((des!=NULL) && (src!=NULL)); 
   	char *address = des;  
   	while((*des++ = *src++) != '\0')  
   		;  
   	return address;
   }
   ```

   要知道 strcpy 会拷贝’\0’，还有要注意：

   - 源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。
   - 要判断源指针和目的指针为空的情况，思维要严谨，这里使用`assert`（见文末）。
   - 要用一个临时变量保存目的串的首地址，最后返回这个首地址。
   - 函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。

   **strlen**:

   ```cpp
   int strlen(const char* str)
   {
   	assert(str != NULL);
   	int len = 0;
   	while((*str++) != '\0')
   		++len;
   	return len;
   }
   ```

   strlen 与 sizeof 的区别：

   - sizeof是运算符，strlen是库函数。
   - sizeof可以用类型、变量做参数，而strlen只能用 char* 变量做参数，且必须以`\0`结尾。
   - sizeof是在编译的时候计算类型或变量所占内存的大小，而strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度。
   - 数组做sizeof的参数不退化，传递给strlen就退化为指针了。

   **strcat**(字符串连接)

   函数`strcat`的原型是`char* strcat(char* des, char* src)`，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。

   ```cpp
   char* strcat(char* des, const char* src)   // const表明为输入参数 
   {  
   	assert((des!=NULL) && (src!=NULL));
   	char* address = des;
   	while(*des != '\0')  // 移动到字符串末尾
   		++des;
   	while(*des++ = *src++)
   		;
   	return address;
   }
   ```

3. static  静态区 常量区 代码区

   答：程序在内存中的分布：①代码区②静态数据区③未初始化数据区（未初始化全局变量和未初始化static）④堆和栈(2 || 8M)

4. new 和 malloc的区别

   1. new 在自由存储区(堆或特殊内存) malloc 一定在堆里

   2. new 返回对象类型指针，malloc 返回 `void*` (malloc可能类型不安全)

   3. new内存分配失败时，会抛出 `bac_alloc` 异常，它不会返回NULL；malloc分配内存失败时返回NULL。

   4. new 不用指定内存块大小，而 malloc 要指定

   5. new 创建对象会：分配内存空间 -> 运行构造函数 -> 返回指向该对象的指针.使用 delete 会先析构再释放内存

      malloc 不会构造和析构

   6. new delete可以重载，malloc 不可以

5. 说一下继承

   答：继承是指可以使用现有类的所有功能，而不需要重新编写原来的类，目的是实现代码复用和支持多态。

6. 堆和栈的区别

   答： 堆：由程序员自己分配，内存由低到高，不连续

   ​	栈：由编译器自动分配释放，内存由高到底，连续

7. STL 中 vector 的实现

   答：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素.

   2 倍增长

8. const 和 define 的区别

   1. define宏是在预处理阶段展开。const常量是编译运行阶段使用。
   2. define宏没有类型，不做任何类型检查，仅仅是展开。　const常量有具体的类型，在编译阶段会执行类型检查。
   3. define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存

9. 发生了内存泄露怎么办

   答：智能指针

10. 智能指针：

    智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放

    > 答：如何来让指针知道还有其他指针的存在呢？这个时候我们该引入**引用计数**的概念了。引用计数是这样一个技巧，它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：
    >
    > - 简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。这也是本文的讨论重点。
    > - 节省内存，提高程序运行效率。如何很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中**string**类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。这不是本文的讨论范围。

    c++11 前： std::auto_ptr，有很多问题。 不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。

    c++11 后：引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。实在想赋值的话，需要使用：std::move

    shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。

    C++11或boost的weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。

    https://blog.csdn.net/worldwindjp/article/details/18843087

11. c++ 对象内存分布

    答：c++中一个类中无非有四种成员：静态数据成员和非静态数据成员，静态函数和非静态函数。

        1.非静态数据成员被放在每一个对象体内作为对象专有的数据成员。
        2.静态数据成员被提取出来放在程序的静态数据区内，为该类所有对象共享，因此只存在一份。
        3.在c++中类的成员函数都是保存在静态存储区中的 ，那静态函数也是保存在静态存储区中的，他们都是在类中保存同一个惫份。
        因此，构成对象本身的只有数据，任何成员函数都不隶属于任何一个对象，非静态成员函数与对象的关系就是绑定，绑定的中介就是this指针。成员函数为该类所有对象共享，不仅是处于简化语言实现、节省存储的目的，而且是为了使同类对象有一致的行为。同类对象的行为虽然一致，但是操作不同的数据成员。

    全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，

    我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。

12. map 底层实现，时间复杂度

    答：红黑树

13. 深拷贝和浅拷贝

    答：深拷贝：复制真正的内存

    ​	浅拷贝：只复制了指针

    ​	当使用 `=` 为浅拷贝 ，使用 `new` 为深拷贝

14. 预编译

    答：预编译头，头文件临时处理。

    ​	文件包含，条件编译、布局控制和宏替换4种。

    ​	文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

    　　条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

    　　布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

    　　宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。

    

## Linux & OS

1. Linux 了解吗，用过什么命令？怎么查看进程的 CPU 状态

   答：`ps -A` :  显示所有进程信息

   ​	`ps -u root` 显示指定用户信息

   ​	`ps -ef` 显示所有进程信息，连同命令行

   ​	`ps -ef|grep ssh` 

2. IPC 方式

   答：管道:它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

   消息队列: 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识.消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。

   信号量: 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量基于操作系统的 PV操作，程序对信号量的操作都是原子操作。

   共享内存:共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步.信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

3. 生产者消费者

4. 银行家算法

5. 进程和线程区别，守护进程

   答：& : 关闭父进程就没了

   ​	nohup : 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。 该命令的一般形式为： `nohup conmmand &`

6. Linux 常用命令 ，查看磁盘容量，cpu 用量 ，各个端口号

   答： `df -lh` `top`  `lsof`

7. Select和epoll区别，epoll为什么快，epoll的底层实现

   答：https://blog.csdn.net/leifukes/article/details/53748403

8. Cpu大端和小端存储

9. 内存对齐，怎么修改对齐基数

10. 协程的概念

    答：只有一个线程，来回执行几个程序。优势是极高的执行效率，不同于多线程.

    第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

## 计算机网络

1. TCP/UCP 的区别
2. UDP 能不能实现可靠连接
3. TCP 流量控制
4. 滑动窗口大小的确定
5. 拥塞控制
6. 三次握手和四次挥手，为什么是 3 次和 4 次，为什么不是两次
7. 三次握手如何标识客户机
8. HTTP 状态码
9. 粘包现象怎么处理
10. TCP 字节流如何在表示层进行封装
11. 快速判断一个数是不是 2 的 n 次幂
12. 解释Time_wait，time_wait连接过多如何解决



## 数据库

1. 说一下几种数据库
2. 