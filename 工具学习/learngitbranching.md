# LearnGitBranching笔记

由于之前学习的 Git 只会进行一些简单操作，没有完全理解，所以重新学习。

学习资料来源于：[learngitbranching](https://learngitbranching.js.org/)

把 Git 理解成一个 DAG(有向无环图)，git 的历史是一个 DAG ，每一个节点代表一个 commit ,每一次提交都在修改这个 DAG ，而 branch 和 tag 仅仅是指向 DAG 这个节点的一个指针。

## 1 主要

### 1.1 基础篇

#### 1.1.1 第 1 关

> Git Commit
> Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！
>
> Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。
>
> Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。
>
> 关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！

**过关方法**：

```bash
git commit
git commit
```

**记录**：

```bash
git commit -m "消息"  #创建一个新的提交记录
```

#### 1.1.2 第 2 关

> Git Branch
> Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：
>
> 早建分支！多用分支！
>
> 这是因为即使创建再多分的支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。
>
> 在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”

**过关方法**：

```bash
git branch bugFix
git checkout bugFix
```

**记录**：

```bash
git branch newImage # 创建一个名字为 newImage 的分支
# 在新的分支中可以继续使用 git commit 提交记录
git checkout name # 切换到名字为 name 的git分支上,所以在对应分支提交内容前先切换分支
git checkout -b name #创建一个名字为 name 的分支且切换到 name 分支上
```

#### 1.1.3 第 3 关

> 分支与合并
> 太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。
>
> 咱们先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”

**过关方法**：

先创建分支 `bugFix` 切过去提交一下，然后切回 `master` 在 master 中提交一次，然后把 `bugFix` 合并到 `master`

```bash
git branch bugFix
git checkout bugFix
git commit
git checkout master
git commit
git merge bugFix # 因此此时在 master 分支，所以就是把 bufFix 和 master 分支合并
```

**记录**：

```bash
git merge name # 把 name 分支与当前分支合并
```

#### 1.1.4 第 4 关

> Git Rebase
> 第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。
>
> Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。

分支状态本来为：

![](https://i.loli.net/2019/04/23/5cbf14b61e73f.png)

当使用：

```bash
git rebase master
```

后使得 bugFix 节点变成了 master 节点的儿子节点

![](https://i.loli.net/2019/04/23/5cbf14b61cc71.png)



此时，C3 节点仍然存在，而 C3' 是 master 上面的 C3 的副本， 然后再更新 master 节点即可。

现在处于 `master` 分支，只需要用 `git rebase bugFix` 更新 master 节点即可。

**过关方法**：

先新建并切换到 `bugFix` 分支没，提交一次，然后再切换回 master 提交一次，再次切换到 bugFix 分支上，rebase 到 master 分支上

```bash
git checkout -b bugFix
git commit
git checkout master
git commit
git checkout bugFix
git rebase master
```

**记录**：

```bash
git rebase name # 给当前节点创建一个副本，并且接到 name 节点的儿子节点
```

### 1.2 高级篇

#### 1.2.1 第 1 关

> 在提交树上移动
> 在接触 Git 更高级功能之前，我们有必要先学习在你项目的提交树上前后移动的几种方法。
>
> 一旦熟悉了如何在 Git 提交树上移动，你驾驭其它命令的能力也将水涨船高！
>
> HEAD
> 我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。
>
> HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。
>
> HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。

![](https://i.loli.net/2019/04/23/5cbf19e2f3898.png)

**过关方法**：

从 bugFix 分支中分离出 HEAD 并让其指向一个提交记录，提交记录用哈希值来表示

```bash
git checkout C4
```

**记录**：

- HEAD 指向当前分支最近的一次提交记录
- 用 `git checkout ` 可以在提交树上移动

#### 1.2.2 第 2 关

> 相对引用
> 通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。
>
> 并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧...
>
> 比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入fed2 而不是上面的一长串字符。

**过关过程**：

切换到 `bugFix` 的父节点。

```bash
git checkout bugFix
git checkout HAED^
```

**记录**：

- 使用 `^` 向上移动一个提交记录
- 使用 `~<num>` 向上移动多个提交记录，如 `-3`

```bash
git checkout HAED^ # 切换成父节点
git checkout HAED^^ # 切换成父节点的父节点
```

#### 1.2.3 第 3 关

> “~”操作符 相对引用
> 如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。
>
> 该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧

**过关过程**：

把对应的节点移到对应的位置。

```bash
git checkout C6
git branch -f master HEAD
git branch -f bugFix HEAD~4
git checkout HEAD~3
```

**记录**：

- 使用 `-f` 选项让分支指向另一个提交

  ```bash
  git branch -f master HEAD~3
  ```

  上面的命令会使 master 分支强制指向 HEAD 的第 3 级父亲节点。

#### 1.2.4 第 4 关

> 撤销变更
> 在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。
>
> 主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。接下来咱们逐个进行讲解。

**过关过程**：

要完成此关，分别撤销 `local` 分支和 `pushed` 分支上的最近一次提交。共需要撤销两个提交（每个分支一个）。

记住 `pushed` 是远程分支，`local` 是本地分支 。

```bash
git reset HEAD^
git checkout pushed
git revert HEAD
```

**记录**：

1. `git reset` 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。`git reset` 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。(这种对于远程分支无效)
2. 为了撤销更改并**分享**给别人，我们需要使用 `git revert`。奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 `C2'` 引入了**更改** —— 这些更改刚好是用来撤销 `C2` 这个提交的。也就是说 `C2'` 的状态与 `C1` 是相同的。

### 1.3 移动提交记录

#### 1.3.1 第 1 关

> 整理提交记录
> 到现在我们已经学习了 Git 的基础知识 —— 提交、分支以及在提交树上移动。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求
>
> 然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。

**过关方法**：

将三个分支中的提交记录复制到 master 上就可以了。

```bash
git cherry-pick C3 C4 C7
```

**记录**：

1. `git cherry-pick <提交号>…` 可以把对应的提交号按照顺序放在当前分支下

#### 1.3.2 第 2 关

> 交互式的 rebase
> 当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。
>
> 但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了
>
> 交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i
>
> 如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。

**过关方法**：

```bash
git rebase -i HEAD~4
然后用鼠标操作
```

**记录**：

1. `git rebase -i` 自己整理记录 

### 1.4 杂项

#### 1.4.1 第 1 关

> 本地栈式提交
> 来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。
>
> 这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！
>
> 最后就差把 bugFix 分支里的工作合并回 master 分支了。你可以选择通过 fast-forward 快速合并到 master 分支上，但这样的话 master 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……
>
> 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用
>
> - `git rebase -i`
> - `git cherry-pick`
>
> 来达到目的。

过关方法：

```bash
git checkout master
git cherry-pick C4
```

#### 1.4.2 第 2 关

> 提交的技巧 #1
> 接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。
>
> 此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。

过关方法：

```bash
git rebase -i HEAD~2 # 改成 3 2
git rebase -i HEAD^ # 2
git rebase -i HEAD~2 # 2 3
git checkout master
git merge caption
```

#### 1.4.3 第 3 关

> 提交的技巧 #2
> 如果你还没有完成“提交的技巧 #1”（前一关）的话，请选通过以后再来！
>
> 正如你在上一关所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 --amend 修改它，然后把它们重新排成我们想要的顺序。
>
> 但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 git cherry-pick 是怎么做的吧。

过关方法：

```bash
git checkout master
git cherry-pick C2
git commit --amend #修改最后一次提交的信息，也就是将本次的改动合并到 master 中
git cherry-pick C3
```

#### 1.4.4 第 4 关

> Git Tags
> 相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。
>
> 你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？
>
> 当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。
>
> 更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。
>
> 咱们来看看标签到底是什么样。

过关方法：

```bash
git tag v0 C1
git checkout C2
git tag v1
```

记录：

1. `git tag v1 c1` 给 c1 这个提交打一个标签命名为 v1
2. `git tag` 给当前 HEAD 所指向提交打标签

#### 1.4.5 第 5 关

> Git Describe
> 由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！
>
> Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。
>
> `git describe` 的语法是：
>
> ```bash
> git describe <ref>
> ```
>
> `<ref>` 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（`HEAD`）。
>
> 它输出的结果是这样的：
>
> ```bash
> <tag>_<numCommits>_g<hash>
> ```
>
> `tag` 表示的是离 `ref` 最近的标签， `numCommits` 是表示这个 `ref` 与 `tag` 相差有多少个提交记录， `hash` 表示的是你所给定的 `ref` 所表示的提交记录哈希值的前几位。
>
> 当 `ref` 提交记录上有某个标签时，则只输出标签名称

过关方法：

```bash
git commit
```

### 1.5 高级话题

#### 1.5.1 第 1 关

> 多分支 rebase
> 哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 master 上吧。
>
> 但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 C6' 在 C7' 上面， C5' 在 C6' 上面，依此类推。
>
> 即使你搞砸了也没关系，用 reset 命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！

过关过程：

```bash
git rebase master bugFix
git rebase bugFix side
git rebase side another
git rebase another master
```

记录：

1. `git rebase a b` 把 b 分支到 lca(a,b) 的这一段复制到 a 的儿子里

#### 1.5.2 第 2 关

> 选择父提交记录
> 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。
>
> 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。
>
> Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。
>
> 废话不多说，举个例子。

过关记录：

```bash
git checkout ~^2~1
git branch bugWork
git checkout master
```

记录：

1. `git checkout HEAD^2` 代表回到当前节点的按照提交顺序(从小到大)的第二个

#### 1.5.3 第 3 关

> 纠缠不清的分支
> 哇塞大神！这关我们要来点不同的！
>
> 现在我们的 master 分支是比 one、two 和 three 要多几个提交。出于某种原因，我们需要把 master 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。
>
> one 需要重新排序并删除 C5，two 仅需要重排排序，而 three 只需要提交一次。
>
> 慢慢来，你会找到答案的 —— 记得通关之后用 show solution 看看我们的答案哦。

过关过程：

```bash
git checkout one
git cherry-pick C4 C3 C2
git checkout two
git cherry-pick C5 C4 C3 C2
git branch -f three C2
```


## 2 远程


### 2.1 Push & Pull — Git远程仓库

#### 2.1.1 第 1 关

> 远程仓库
> 远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录
>
> 话虽如此, 远程仓库却有一系列强大的特性
>
> 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。
>
> 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)
>
> 现在用网站来对远程仓库进行可视化操作变得越发流行了(像 Github 或 Phabricator), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要!

过关方法：

```bash
git clone
```

#### 2.1.2 第 2 关

> 远程分支
> 既然你已经看过 git clone 命令了，咱们深入地看一下发生了什么。
>
> 你可能注意到的第一个事就是在我们的本地仓库多了一个名为 o/master 的分支, 这种类型的分支就叫远程分支。由于远程分支的特性导致其拥有一些特殊属性。
>
> 远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.
>
> 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。
>
> 为什么有 `o/`？
>
> 你可能想问这些远程分支的前面的 `o/` 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:
>
> - `<remote name>/<branch name>`
>
> 因此，如果你看到一个名为 `o/master` 的分支，那么这个分支就叫 `master`，远程仓库的名称就是 `o`。
>
> 大多数的开发人员会将它们主要的远程仓库命名为 `origin`，并不是 `o`。这是因为当你用 `git clone` 某个仓库时，Git 已经帮你把远程仓库的名称设置为 `origin` 了
>
> 不过 `origin` 对于我们的 UI 来说太长了，因此不得不使用简写 `o` :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 `origin`!

过关方法：

在 `master` 分支上做一次提交；然后检出 `o/master`，再做一提交。这有助于你理解远程分支的不同，他们的更新只是反映了远程的状态。

```bash
git checkout master
git commit
git checkout C1
git commit
```

#### 2.1.3 第 3 关

> Git Fetch
> Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。
>
> 本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch。
>
> 你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。在上一了我们已经提及过这一点了。
>
> git fetch 做了些什么
>
> `git fetch` 完成了仅有的但是很重要的两步:
>
> - 从远程仓库下载本地仓库中缺失的提交记录
> - 更新远程分支指针(如 `o/master`)
>
> `git fetch` 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。
>
> 如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，`git fetch` 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 `git fetch` 与远程分支之间的关系了吧。
>
> `git fetch` 通常通过互联网（使用 `http://` 或 `git://` 协议) 与远程仓库通信。
>
> git fetch 不会做的事
>
> `git fetch` 并不会改变你本地仓库的状态。它不会更新你的 `master` 分支，也不会修改你磁盘上的文件。
>
> 理解这一点很重要，因为许多开发人员误以为执行了 `git fetch` 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D
>
> 所以, 你可以将 `git fetch` 的理解为单纯的下载操作。

过关方法：

```bash
git fetch
```

#### 2.1.4 第 4 关

> Git Pull
>
> 既然我们已经知道了如何用 `git fetch` 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。
>
> 其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:
>
> - `git cherry-pick o/master`
> - `git rebase o/master`
> - `git merge o/master`
> - 等等
>
> 实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 `git pull`。

过关方法：

```bash
git pull
```

#### 2.1.5 第 5 关

> 模拟团队合作
>
> 这里有一件棘手的事 —— 为了接下来的课程, 我们需要先教你如何制造远程仓库的变更。
>
> 这意味着，我们需要“假装”你的同事、朋友、合作伙伴更新了远程仓库，有可能是某个特定的分支，或是几个提交记录。
>
> 为了做到这点，我们引入一个自造命令 `git fakeTeamwork`！它的名称已经说明了一切，先看演示..
>
> `fakeTeamwork` 默认操作就是在远程仓库的 master 分支上做一次提交。

过关方法：

克隆一个远程仓库（用 `git clone`），再在刚创建的远程仓库中模拟一些修改，然后在你自己的本地分支上做一些提交，再拉取远程仓库的变更。这看起来像是包含了好几节的课程。

```bash
git clone
git fakeTeamwork master 2
git commit
git pull
```

#### 2.1.6 第 6 关

> Git Push
>
> OK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享**我的**成果呢？
>
> 嗯，上传自己分享内容与下载他人的分享刚好相反，那与 `git pull` 相反的命令是什么呢？`git push`！
>
> `git push` 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 `git push` 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！
>
> 你可以将 `git push` 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……
>
> *注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。*

过关方法：

```bash
git commit
git commit
git push
```

#### 2.1.7 第 7 关

> 偏离的工作
>
> 现在我们已经知道了如何从其它地方 `pull` 提交记录，以及如何 `push` 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？
>
> 困难来自于远程库提交历史的**偏离**。在讨论这个问题的细节前，我们先来看一个例子……
>
> 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。
>
> 这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，异或由于你的提交已经过时而直接忽略你的提交？
>
> 因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。
>
> `git push` 失败是因为你最新提交的 `C3` 基于远程分支中的 `C1`。而远程仓库中该分支已经更新到 `C2` 了，所以 Git 拒绝了你的推送请求。

过关方法：

要完成本关，你需要完成以下几步：

- 克隆你的仓库
- 模拟一次远程提交（fakeTeamwork）
- 完成一次本地提交
- 用 `rebase` 发布你的工作

```bash
git clone 
git fakeTeamwork
git commit
git pull --rebase
git push
```

记录：

1. `git pull` 与 `git pull --rebase` 的区别是，pull 是把远程仓库的先弄过来，然后和本地的合并成一个新的

   但是，`--rebase` 是先把远程库的和自己之前库里的的接上，然后当前的更新是原节点的儿子。

### 2.2 关于 origin 和它的周边 —— Git 远程仓库高级操作

